---
title: "Percentile Demonstration"
author: "D.E. Beaudette"
date: "`r Sys.Date()`"
output:
  html_document:
    mathjax: null
    jquery: null
    smart: no
    keep_md: no
---

```{r setup, echo=FALSE, results='hide', warning=FALSE}
# setup
library(knitr)
opts_chunk$set(message=FALSE, warning=FALSE, background='#F7F7F7', fig.retina=2, dev='png', tidy=FALSE, verbose=FALSE, cache = FALSE)
options(width=100, stringsAsFactors=FALSE, cache=FALSE)
```


```{r  echo=FALSE, results='hide', warning=FALSE}
library(soilDB)
library(scales)
library(Hmisc)
library(rgdal)
library(raster)
library(sharpshootR)

# convenient summary of vector x, can contain NA
f.summary <- function(x) {
  n <- length(na.omit(x))
  frac.NA <- round( (1 - ( length(na.omit(x)) / length(x) ) ) * 100)
  x.mean <- mean(x, na.rm=TRUE)
  x.sd <- sd(x, na.rm=TRUE)
  x.min <- min(x, na.rm=TRUE)
  x.max <- max(x, na.rm=TRUE)
  pr <- c(0.05, 0.1, 0.5, 0.9, 0.95)
  q <- t(hdquantile(x, probs = c(0.05, 0.1, 0.5, 0.9, 0.95), na.rm=TRUE))
  dimnames(q)[[2]] <- paste0('P', pr * 100)
  d <- data.frame(mean=x.mean, sd=x.sd, min=x.min, max=x.max, q, n, frac.NA)
  return(d)
}

## borrowed from MU reports
# remove NA
# re-scale to {0,1}
# return x,y values
scaled.density <- function(x) {
  res <- stats::density(na.omit(x), cut=1)
  return(data.frame(x=res$x, y=scales::rescale(res$y)))
}


compare.with.mean <- function(x, labels.signif=3, pctile.color='RoyalBlue', mean.color='Orange', range.color='DarkRed', boxp=FALSE, ...) {
  
  # prep values
  s <- f.summary(x)
  x <- na.omit(x)
  
  # plot parameters
  y.base.pctiles <- -0.05
  y.base.normal <- -0.12
  y.base.range <- -0.19
  
  # density plot of the data, scaled to {0,1}
  d.x <- scaled.density(x)
  # idealized normal over interval of the data
  x.seq <- seq(s$mean - 2.5 * s$sd, s$mean + 2.5 * s$sd, length.out = 100)
  ideal.normal <- cbind(x.seq, scales::rescale(dnorm(x.seq, mean=s$mean, sd=s$sd)))
  
  # setup plot
  plot(d.x, type='n', ylim=c(-0.2, 1.1), axes=FALSE, ...)
  abline(h=c(0, 1), col=grey(0.85))
  lines(d.x, lwd=2)
  lines(ideal.normal)
  
  
  ## boxplot for reference
  if(boxp) {
    y.base.range <- y.base.range - 0.02
    y.base.normal <- y.base.normal - 0.02
    y.base.pctiles <- y.base.pctiles - 0.02
    
    boxplot(x, at=-0.02, add=TRUE, axes=FALSE, horizontal=TRUE, boxwex=0.05, lwd=1, cex=0.5)
    # boxplot(rnorm(5000, mean=s$mean, sd=s$sd), at=1, add=TRUE, axes=FALSE, horizontal=TRUE, boxwex=0.05, col='grey')
  }
    
  
  ## percentiles
  # lower / upper pctile
  segments(x0=s$P10, x1=s$P90, y0=y.base.pctiles, y1=y.base.pctiles, col=pctile.color, lwd=2)
  segments(x0=c(s$P10, s$P90), x1=c(s$P10, s$P90), y0=y.base.pctiles, y1=1, lty=3, col=pctile.color)
  # median
  segments(x0=s$P50, x1=s$P50, y0=y.base.pctiles, y1=1, lty=3, col=pctile.color)
  points(s$P50, y.base.pctiles, cex=1.2, pch=22, bg=pctile.color)
  # add values
  text(x=c(s$P10, s$P50, s$P90), y=y.base.pctiles - 0.025, label=signif(c(s$P10, s$P50, s$P90), labels.signif), cex=0.65)
  
  ## idealized normal
  # +/- SD
  segments(x0=(-2 * s$sd) + s$mean, x1=(2 * s$sd) + s$mean, y0=y.base.normal, y1=y.base.normal, col=mean.color, lwd=2)
  segments(x0=(-2 * s$sd) + s$mean, x1=(-2 * s$sd) + s$mean, y0=y.base.normal, y1=1, lty=3, col=mean.color)
  segments(x0=(2 * s$sd) + s$mean, x1=(2 * s$sd) + s$mean, y0=y.base.normal, y1=1, lty=3, col=mean.color)
  # mean
  segments(x0=s$mean, x1=s$mean, y0=y.base.normal, y1=1, lty=3, col=mean.color)
  points(s$mean, y.base.normal, cex=1.25, pch=22, bg=mean.color)
  # add values
  text(x=c(((-2 * s$sd) + s$mean), s$mean, ((2 * s$sd) + s$mean)), y=y.base.normal - 0.025, label=signif(c(((-2 * s$sd) + s$mean), s$mean, ((2 * s$sd) + s$mean)), labels.signif), cex=0.65)
  
  ## min / max
  # +/- SD
  segments(x0=s$min, x1=s$max, y0=y.base.range, y1=y.base.range, col=range.color, lwd=2)
  segments(x0=s$min, x1=s$min, y0=y.base.range, y1=1, lty=3, col=range.color)
  segments(x0=s$max, x1=s$max, y0=y.base.range, y1=1, lty=3, col=range.color)
    # add values
  text(x=c(s$min, s$max), y=y.base.range - 0.025, label=signif(c(s$min, s$max), labels.signif-1), cex=0.65)
  
  # finish basic axix / box
  axis(side=1, at = pretty(x, n = 10))
  box()
  
  # combined legend
  legend('top', lwd=c(2,2,2,2,1, NA), lty=c(1,1,1,1,1, NA), col=c(pctile.color, mean.color, range.color, 'black', 'black'), legend = c('10th-50th-90th', 'Mean +/- 2SD', 'Min / Max', 'Source Dist', 'Ideal Normal', paste('Obs:', s$n)), horiz=TRUE, bty='n', cex=0.8)
  
  invisible(s)
}

# get a subset of a given variable from an SPC, by pattern matching against hz designation
subsetData <- function(SPC, hzname, hz_pat, var) {

  h <- horizons(SPC)
  idx <- grep(hz_pat, h[[hzname]])
  x <- h[[var]][idx]
  return(x)
}

```


```{r echo=FALSE, warning=FALSE}
reMakeData <- FALSE

if(reMakeData) {
  # get some sample data
  kssl <- fetchKSSL('miami')
  nasis <- fetchNASIS(rmHzErrors = FALSE)
  
  idx <- grep('loafercreek', nasis$taxonname, ignore.case = TRUE)
  loafercreek <- nasis[idx, ]
  
  idx <- grep('amador', nasis$taxonname, ignore.case = TRUE)
  amador <- nasis[idx, ]
  
  idx <- grep('Nedsgulch', nasis$taxonname, ignore.case = TRUE)
  nedsgulch <- nasis[idx, ]
  
  # best possible scenario: rasters are in memory
  r.elev <- readAll(raster('E:/gis_data/ca630/ca630_elev/hdr.adf'))
  r.slope <- readAll(raster('E:/gis_data/ca630/ca630_slope/hdr.adf'))
  r.MAP <- readAll(raster('E:/gis_data/prism/final_MAP_mm_800m.tif'))
  
  # load map unit polygons
  mu <-  readOGR(dsn='E:/gis_data/ca630/FG_CA630_OFFICIAL.gdb', layer='ca630_a', stringsAsFactors = FALSE)
  
  # add a unique polygon ID
  mu$pID <- seq(from=1, to=length(mu))
  
  # extract polygons for a single map unit ("MUSYM" attribute = "7089")
  # note that column names in your data may be different
  mu.5012 <- mu[which(mu$MUSYM == '5012'), ]
  
  # generate sampling points
  s <- constantDensitySampling(mu.5012, n.pts.per.ac=1, min.samples=1, polygon.id='pID')
  
  # extract raster data
  e.elev <- extract(r.elev, s)
  e.slope <- extract(r.slope, s)
  e.MAP <- extract(r.MAP, s)
  
  # save for later
  save(kssl, loafercreek, amador, nedsgulch, e.elev, e.slope, e.MAP, file='cached-data.rda')
} else {
  # get cached version
  load(file='cached-data.rda')
}

```

```{r echo=FALSE, results='hide', warning=FALSE, fig.width=9, fig.height=6.5}
par(mar=c(4.5,1,2,1))

# explanation of figures with random data

set.seed(101010)
x <- rnorm(100, mean=15, sd=2)
res <- compare.with.mean(x, xlab='Percent Clay', main='KSSL: Miami, B Horizons')

set.seed(101010)
x <- rlnorm(100, meanlog = log(15), sdlog = log(1.5))
res <- compare.with.mean(x, xlab='Percent Clay', main='KSSL: Miami, B Horizons')

set.seed(101010)
x <- rlnorm(100, meanlog = log(15), sdlog = log(3))
res <- compare.with.mean(x, xlab='Percent Clay', main='KSSL: Miami, B Horizons')

x <- rbeta(1000, 2, 20) * 100
res <- compare.with.mean(x, xlab='Percent Clay', main='KSSL: Miami, B Horizons')
```


```{r echo=FALSE, results='hide', warning=FALSE, fig.width=9, fig.height=6.5}
par(mar=c(4.5,1,2,1))

x <- subsetData(kssl, hzname = 'hzn_desgn', hz_pat = 'B', var = 'clay')
res <- compare.with.mean(x, xlab='Percent Clay', main='KSSL: Miami, B Horizons')

x <- subsetData(kssl, hzname = 'hzn_desgn', hz_pat = 'A', var = 'estimated_oc')
res <- compare.with.mean(x, xlab='Organic Carbon (%)', main='KSSL: Miami, A Horizons')

x <- subsetData(kssl, hzname = 'hzn_desgn', hz_pat = 'B', var = 'estimated_ph_h2o')
res <- compare.with.mean(x, xlab='pH (%)', main='KSSL: Miami, B Horizons')

```

```{r  echo=FALSE, results='hide', warning=FALSE, fig.width=9, fig.height=6.5}
par(mar=c(4.5,1,3,1))

x <- subsetData(loafercreek, hzname = 'hzname', hz_pat = 'B', var = 'total_frags_pct')
res <- compare.with.mean(x, xlab='Total Fragment Volume', main='NASIS: Loafercreek, B Horizons')

x <- subsetData(loafercreek, hzname = 'hzname', hz_pat = 'B', var = 'clay')
res <- compare.with.mean(x, xlab='Percent Clay', main='NASIS: Loafercreek, B Horizons')
```



```{r  echo=FALSE, results='hide', warning=FALSE, fig.width=9, fig.height=6.5}
par(mar=c(4.5,1,3,1))
res <- compare.with.mean(e.elev, xlab='Elevation (m)', main='CA630: 5012')
res <- compare.with.mean(e.slope, xlab='Slope (%)', main='CA630: 5012')
res <- compare.with.mean(e.MAP, xlab='PRISM Mean Annual PPT (mm)', main='CA630: 5012')
```







